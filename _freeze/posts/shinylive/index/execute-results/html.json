{
  "hash": "4f7245131c2210941b2a2a142e0e3c39",
  "result": {
    "markdown": "---\ntitle: shinylive\ndate: 2023-10-27\ntitle-block-banner: false \nimage: \"image.png\"\nbibliography: \"bibliography.bib\"\nnocite: |\n     @*\ncode-fold: true\ncomments:\n   giscus: \n     repo: robertwwalker/robertwwalker.github.io\n---\n\n\n<marquee scrollamount=\"10\"><h1><p style=\"color:purple;\">{{< fa brands r-project >}}obertwwalker.github.io <br></p></h1></marquee>\n\n\n\n\n\n\n# shinylive, finally....\n\nIn his talk at `rstudio::conf`, Joe Cheng discussed the arrival of `shinylive` for `R`.  Coming almost a year after the python deployment, it is really nice to think about teaching it and not having to teach computer science but it would have to reliably work for that dream to become reality.  So I decided to try it out.\n\n## tldr;\n\nTake an app and try to build it into shinylive.  It works.\n\n## What is involved?\n\nHere is my app.  I do not know where it originally came from -- the data that is -- but it is very simple.\n\n```\n# Forecasting Google ----\n# It supports 3 stats forecasting models - Linear Regression, ARIMA, and Holt-Winters\n\nlibrary(shiny)\nGOOG <- [data downloaded via tq_get in tidyquant and turned into a daily ts object, check the repo for the actual data]\n# UI ----\nui <- fluidPage(\n  \n  # App title ----\n  titlePanel(\"Forecasting Sandbox\"),\n  sidebarLayout(\n    \n    sidebarPanel(width = 3,\n                 selectInput(inputId = \"model\",\n                             label = \"Select Model\",\n                             choices = c(\"Linear Regression\", \"ARIMA\", \"Holt-Winters\"),\n                             selected = \"Linear Regression\"),\n                 # Linear Regression model arguments\n                 conditionalPanel(condition = \"input.model == 'Linear Regression'\",\n                                  checkboxGroupInput(inputId = \"lm_args\", \n                                                     label = \"Select Regression Features:\", \n                                                     choices = list(\"Trend\" = 1, \n                                                                    \"Seasonality\" = 2),\n                                                     selected = 1)),\n                 # ARIMA model arguments\n                 conditionalPanel(condition = \"input.model == 'ARIMA'\",\n                                  h5(\"Order Parameters\"),\n                                  sliderInput(inputId = \"p\",\n                                              label = \"p:\",\n                                              min = 0,\n                                              max = 5,\n                                              value = 0),\n                                  sliderInput(inputId = \"d\",\n                                              label = \"d:\",\n                                              min = 0,\n                                              max = 5,\n                                              value = 0),\n                                  sliderInput(inputId = \"q\",\n                                              label = \"q:\",\n                                              min = 0,\n                                              max = 5,\n                                              value = 0),\n                                  h5(\"Seasonal Parameters:\"),\n                                  sliderInput(inputId = \"P\",\n                                              label = \"P:\",\n                                              min = 0,\n                                              max = 5,\n                                              value = 0),\n                                  sliderInput(inputId = \"D\",\n                                              label = \"D:\",\n                                              min = 0,\n                                              max = 5,\n                                              value = 0),\n                                  sliderInput(inputId = \"Q\",\n                                              label = \"Q:\",\n                                              min = 0,\n                                              max = 5,\n                                              value = 0)\n                 ),\n                 # Holt Winters model arguments\n                 conditionalPanel(condition = \"input.model == 'Holt-Winters'\",\n                                  checkboxGroupInput(inputId = \"hw_args\", \n                                                     label = \"Select Holt-Winters Parameters:\", \n                                                     choices = list(\"Beta\" = 2, \n                                                                    \"Gamma\" = 3),\n                                                     selected = c(1, 2, 3)),\n                                  selectInput(inputId = \"hw_seasonal\",\n                                              label = \"Select Seasonal Type:\",\n                                              choices = c(\"Additive\", \"Multiplicative\"),\n                                              selected = \"Additive\")),\n                 \n                 checkboxInput(inputId = \"log\", \n                               label = \"Log Transformation\",\n                               value = FALSE),\n                 sliderInput(inputId = \"h\",\n                             label = \"Forecasting Horizon:\",\n                             min = 1,\n                             max = 60,\n                             value = 24)\n                 #   actionButton(inputId = \"update\",\n                 #                 label = \"Update!\")\n                 \n    ),\n    \n    # Main panel for displaying outputs ----\n    mainPanel(width = 9,\n              # Forecast Plot ----\n              plotOutput(outputId = \"fc_plot\",\n                         height = \"400px\")\n              \n    )\n  )\n)\n\n# Define server logic required to draw a histogram ----\nserver <- function(input, output) {\n  # Load the dataset a reactive object\n  d <- reactiveValues(df = data.frame(input = as.numeric(GOOG), \n                                      index = seq.Date(from= as.Date(\"2016-05-19\"),\n                                                       by = \"day\",\n                                                       length.out = length(GOOG))),\n                      air = GOOG)\n  \n  # Log transformation \n  observeEvent(input$log,{\n    if(input$log){\n      d$df <- data.frame(input = log(as.numeric(GOOG)), \n                         index = seq.Date(from = as.Date(\"2016-05-19\"),\n                                          by = \"day\",\n                                          length.out = length(GOOG)))\n      \n      d$air <- log(GOOG)\n    } else {\n      d$df <- data.frame(input = as.numeric(GOOG), \n                         index = seq.Date(from = as.Date(\"2016-05-19\"),\n                                          by = \"day\",\n                                          length.out = length(GOOG)))\n      \n      d$air <- GOOG\n    }\n  })\n  \n  # The forecasting models execute under the plot render\n  output$fc_plot <- renderPlot({\n    \n    # if adding a prediction intervals level argument set over here\n    pi <- 0.95\n    \n    # Holt-Winters model\n    if(input$model == \"Holt-Winters\"){\n      a <- b <- c <- NULL\n      \n      if(!\"2\" %in% input$hw_args){\n        b <- FALSE\n      }\n      \n      if(!\"3\" %in% input$hw_args){\n        c <- FALSE\n      }\n      \n      md <- HoltWinters(d$air, \n                        seasonal = ifelse(input$hw_seasonal == \"Additive\", \"additive\", \"multiplicative\"),\n                        beta = b,\n                        gamma = c\n      )\n      fc <- predict(md, n.ahead = input$h, prediction.interval = TRUE) |>\n        as.data.frame()\n      fc$index <- seq.Date(from = as.Date(Sys.Date()),\n                           by = \"day\",\n                           length.out = input$h)\n      # ARIMA model\n    } else if(input$model == \"ARIMA\"){\n      \n      md <- arima(d$air,\n                  order = c(input$p, input$d, input$q),\n                  seasonal = list(order = c(input$P, input$D, input$Q))\n      )\n      fc <- predict(md, n.ahead = input$h, prediction.interval = TRUE) |>\n        as.data.frame() \n      names(fc) <- c(\"fit\", \"se\")\n      \n      fc$index <- seq.Date(from = as.Date(Sys.Date()),\n                           by = \"day\",\n                           length.out = input$h)\n      \n      fc$upr <- fc$fit + 1.96 * fc$se\n      fc$lwr <- fc$fit - 1.96 * fc$se\n      # Linear Regression model\n    } else if(input$model == \"Linear Regression\"){\n      \n      d_lm <- d$df\n      \n      d_fc <- data.frame(index = seq.Date(from = as.Date(Sys.Date()),\n                                          by = \"day\",\n                                          length.out = input$h))\n      \n      if(\"1\" %in% input$lm_args){\n        d_lm$trend <- 1:nrow(d_lm)\n        d_fc$trend <- (max(d_lm$trend) + 1):(max(d_lm$trend) + input$h)\n      }\n      \n      if(\"2\" %in% input$lm_args){\n        d_lm$season <- as.factor(months((d_lm$index)))\n        d_fc$season <- factor(months((d_fc$index)), levels = levels(d_lm$season))\n      }\n      \n      md <- lm(input ~ ., data = d_lm[, - which(names(d_lm) == \"index\")])\n      \n      fc <- predict(md, n.ahead = input$h, interval = \"prediction\",\n                    level = pi, newdata = d_fc) |>\n        as.data.frame() \n      \n      \n      fc$index <- seq.Date(from = as.Date(Sys.Date()),\n                           by = \"day\",\n                           length.out = input$h)\n      \n    }\n    \n    # Setting the plot\n    at_x <- pretty(seq.Date(from = min(d$df$index),\n                            to = max(fc$index),\n                            by = \"day\"))\n    \n    at_y <- c(pretty(c(d$df$input, fc$upr)), 60)\n    \n    plot(x = d$df$index, y = d$df$input,\n         col = \"#1f77b4\",\n         type = \"l\",\n         frame.plot = FALSE,\n         axes = FALSE,\n         panel.first = abline(h = at_y, col = \"grey80\"),\n         main = \"GOOG Forecast\",\n         xlim = c(min(d$df$index), max(fc$index)),\n         ylim = c(min(c(min(d$df$input), min(fc$lwr))), max(c(max(fc$upr), max(d$df$input)))),\n         xlab = paste(\"Model:\", input$model, sep = \" \"),\n         ylab = \"GOOG Price\")\n    mtext(side =1, text = format(at_x, format = \"%Y-%M\"), at = at_x,\n          col = \"grey20\", line = 1, cex = 0.8)\n    \n    mtext(side =2, text = format(at_y, scientific = FALSE), at = at_y,\n          col = \"grey20\", line = 1, cex = 0.8)\n    lines(x = fc$index, y = fc$fit, col = '#1f77b4', lty = 2, lwd = 2)\n    lines(x = fc$index, y = fc$upr, col = 'blue', lty = 2, lwd = 2)\n    lines(x = fc$index, y = fc$lwr, col = 'blue', lty = 2, lwd = 2)\n    \n  })\n  \n}\n\n# Create Shiny app ----\nshinyApp(ui = ui, server = server)\n```\n\nThe first step is to start a new shiny project.  For this one, I will use `renv` as the documents suggest this to be useful.  The `New project` dialog can be used to accomplish nearly all of this.\n\n![Screenshot](img/Screenshot 2023-11-17 at 1.26.47 PM.png)\n\nOk.  Now there is a shiny app in a directory to use.  Now let's try the shinylive package.\n\n```\ninstall.packages(\"shinylive\")\n```\n\nIn theory, there is not that much to it so long as the app works with `webR`.  So let's compile it up and see what happens.  There is an `app.R` file in `myapp` and that becomes the `docs` directory when transformed by shiny live.  This all exists in a repository called `SLT2` that can be found [here](https://github.com/robertwwalker/SLT2/).  At first, I wanted to put it as a subdirectory here but could not quite get it all to render properly.  With the separate repo, building the app in `docs` means that github pages can render it.\n\n```\nshinylive::export(appdir = \"myapp\", outputdir = \"docs\")\n```\n\n![Screenshot](img/Screenshot 2023-11-20 at 8.51.11 PM.png)\n\nIf it works, the `docs` directory of that repository has a [forecasting app](https://robertwwalker.github.io/SLT2/index.html).  I serve it using github pages.\n\n# References\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(plumber)\nknitr::write_bib(names(sessionInfo()$otherPkgs), file=\"bibliography.bib\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}